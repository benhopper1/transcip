console.log('==================================================================');
console.log('--  FILE STORAGE SERVER  -----------------------------------------');
console.log('==================================================================');
var path = require('path');
var basePath = path.dirname(require.main.filename);
console.log('path:' + basePath);
var fs = require('fs');
var extend = require(basePath + '/node_modules/node.extend');
var finish = require(basePath + '/node_modules/finish');
var util = require('util');
var uuid = require(basePath + '/node_modules/node-uuid');
var JsonFile = require(basePath + '/node_modules/jsonfile');


//sftp://ben@192.168.0.16/home/ben/git_project/transcip/cip/node_modules
//sftp://ben@192.168.0.16/home/ben/git_project/transcip/trans/express/

var FileStorageServer = function(inOptions){
	var options = 
		{
			//datFilePath:'filestoragedat.json',
			datFilePath:path.join(basePath, '..', '/trans/express/filestoragedat.json'),
		}
	options = extend(true, options, inOptions);

	var _this = this;
	var fileStoragehash = {};
	var timerId = false;

	//@@@@@@@@ READ DAT AS INPUT @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.readInDatFile = function(){
		fileStoragehash = JsonFile.readFileSync(options.datFilePath);
	}

	//@@@@@@@@ WRITE DAT AS OUTPUT @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.writeOutDatFile = function(){
		JsonFile.writeFileSync(options.datFilePath, fileStoragehash);
	}

	//@@@@@@@@ OVER RIDE FILE   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.overRideDatFile = function(inOverRideDatFileOptions){
		_this.readInDatFile();
		var overRideDatFileOptions = fileStoragehash;
		overRideDatFileOptions = extend(true, overRideDatFileOptions, inOverRideDatFileOptions);
		fileStoragehash = overRideDatFileOptions;
		_this.writeOutDatFile();
	}

	//@@@@@@@@ CALC ALL  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.calcAll = function(inPostFunction){
		var allResults = [];
		finish.map(Object.keys(fileStoragehash), function(theItem, done){
			_this.calcForKey(theItem, function(inResultOfItem){
				allResults.push(inResultOfItem);
				done();
			});
		},//completed Function--------------------------------
		function(err, results){
			if(inPostFunction){
				inPostFunction(allResults);
			}
		});
	}
	//@@@@@@@@ CALC    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.calcForKey = function(inStorageKey, inPostFunction){
		var theFolderBasePath = fileStoragehash[inStorageKey].folderBasePath;
		if(!(fileStoragehash[inStorageKey])){return false;}
		fs.readdir(theFolderBasePath, function(err, files){
			var totalFileCount = 0;
			var totalFileSizeBytes = 0;
			fileStoragehash[inStorageKey].folders = {};
			var folders = fileStoragehash[inStorageKey].folders;
			for(var fileIndex in files){
				if(fs.statSync(path.join(theFolderBasePath, files[fileIndex])).isDirectory()){
					//FOLDER-----
					fileStoragehash[inStorageKey].currentTotalFolderCount++;
					folders[files[fileIndex]] = 
						{
							name:files[fileIndex],
							fullPath:theFolderBasePath + files[fileIndex],
							currentFolderFileCount:0,
							currentFolderFileSizeBytes:0,
						}
				}else{
					//FILE-----------
				}
			}
			//process the folders.....
			var doOnce = true;
			var totalVacantCount = 0;
			
			finish.map(folders, function(folder, done){
				if(doOnce){
					doOnce = false;
					fileStoragehash[inStorageKey].leastFolderCount = 10000000;
				}
				fs.readdir(folder.fullPath, function(err, inFiles){
					fileStoragehash[inStorageKey].useFolderPath = folder.name;//primer

					for(var inFileIndex in inFiles){
						if(fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).isDirectory()){
							//ignored, only 1 level processing, switch to recursion if want more...
						}else{
							folder.currentFolderFileCount++,
							folder.currentFolderFileSizeBytes += fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).size;
						}
					}
					if(folder.currentFolderFileCount < fileStoragehash[inStorageKey].maxFolderFileCount){
						totalVacantCount += (fileStoragehash[inStorageKey].maxFolderFileCount - folder.currentFolderFileCount);
					}
					
					

					fileStoragehash[inStorageKey].currentTotalFileCount += folder.currentFolderFileCount;
					fileStoragehash[inStorageKey].currentTotalFileSize += folder.currentFolderFileSizeBytes;
					done();
				});
			},
			//completed Function--------------------------------
			function(err, results){
				_this.pickMostVacantFolder(inStorageKey);
				fileStoragehash[inStorageKey].currentFolderUsageCountPercent = (100 - (totalVacantCount / ((Object.keys(fileStoragehash[inStorageKey].folders).length) * fileStoragehash[inStorageKey].maxFolderFileCount)) * 100);
				
				if(inPostFunction){
					inPostFunction(fileStoragehash[inStorageKey]);
				}
			});
		});
	}

	_this.pickMostVacantFolder = function(inStorageKey){
		var theStruct = fileStoragehash[inStorageKey].folders;
		var leastCount = 1000000;
		var tmp = false;
		for(theKey in theStruct){
			if(theStruct[theKey].currentFolderFileCount < leastCount){
				leastCount = theStruct[theKey].currentFolderFileCount;
				tmp = theKey;
			}
		}
		fileStoragehash[inStorageKey].leastFolderCount = leastCount;
		fileStoragehash[inStorageKey].useFolderPath = tmp;
	}

	this.checkAndCreateVacancy = function(inPostFunction){
		var resultBool = false;
		_this.calcAll(function(result){
			for(var theKey in fileStoragehash){
				
				if(isNaN(fileStoragehash[theKey].currentFolderUsageCountPercent)){
					_this.createFolder(theKey);
				}
				
				if(fileStoragehash[theKey].currentFolderUsageCountPercent >= fileStoragehash[theKey].createNewFolderUsageCountPercent){
					resultBool = true;
					_this.createFolder(theKey);
				}
			}
			_this.calcAll(function(result){
				if(inPostFunction){inPostFunction(resultBool);}
			});
		});
	}

	this.createFolder = function(inStorageKey){
		var baseFolderPath = fileStoragehash[inStorageKey].folderBasePath;
		var newFolderName = uuid.v1();
		var fullPath = baseFolderPath + newFolderName;
		fs.mkdirSync(fullPath);
		fileStoragehash[inStorageKey].folders[newFolderName] =
			{
				name:newFolderName,
				fullPath:fullPath,
				currentFolderFileCount:0,
				currentFolderFileSizeBytes:0,
			}

		fileStoragehash[inStorageKey].useFolderPath = newFolderName;
	}

	this.startCycle = function(inInterval, inCycleFunction){
		_this.readInDatFile();
		var theCycleFunction = function(){
			_this.checkAndCreateVacancy(function(hadIncrease){
				_this.writeOutDatFile();
				timerId = setTimeout(function(){ theCycleFunction(); }, inInterval);
			});
		}
		theCycleFunction();
	}

	this.stopCycle = function(){
		if(timerId){
			clearTimeout(timerId);
		}
	}
}
module.exports = FileStorageServer;

//testin here----------------------------------
/*


//--------testing area --------
var fileStorageServer = new FileStorageServer(
	{
		datFilePath:FILE_STORAGE_DAT,
	}
);

var counter = 0;
fileStorageServer.startCycle(5000, function(){

});


*/










/*fileStorageServer.readInDatFile();
fileStorageServer.checkAndCreateVacancy(function(hadIncrease){
	console.log('checkAndCreateVacancy hadIncrease:' + hadIncrease);
	fileStorageServer.writeOutDatFile();
});
*/
/*fileStorageServer.calcAll(function(result){
	console.log('calc All done:');
	console.dir(result);
	fileStorageServer.writeOutDatFile();
});*/

