console.log('==================================================================');
console.log('--  FILE STORAGE SERVER  -----------------------------------------');
console.log('==================================================================');
var path = require('path');
var basePath = path.dirname(require.main.filename);
var fs = require('fs');
var extend = require(basePath + '/node_modules/node.extend');
var finish = require(basePath + '/node_modules/finish');
var util = require('util');
var uuid = require(basePath + '/node_modules/node-uuid');
var JsonFile = require(basePath + '/node_modules/jsonfile');
var FileStorageServerModel = require(basePath + '/models/filestorageservermodel');
var fileStorageServerModel = new FileStorageServerModel();
var moment = require(basePath + '/node_modules/moment');


var FileStorageServer = function(inOptions){
	var options = 
		{
			datFilePath:path.join(basePath, '..', '/trans/express/filestoragedat.json'),
		}
	options = extend(true, options, inOptions);

	var _this = this;
	var fileStoragehash = {};
	var timerId = false;

	//@@@@@@@@ READ DAT AS INPUT @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.readInDatFile = function(){
		fileStoragehash = JsonFile.readFileSync(options.datFilePath);
		return fileStoragehash;
	}

	//@@@@@@@@ WRITE DAT AS OUTPUT @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.writeOutDatFile = function(){
		JsonFile.writeFileSync(options.datFilePath, fileStoragehash);
	}

	//@@@@@@@@ OVER RIDE FILE   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.overRideDatFile = function(inOverRideDatFileOptions){
		_this.readInDatFile();
		var overRideDatFileOptions = fileStoragehash;
		overRideDatFileOptions = extend(true, overRideDatFileOptions, inOverRideDatFileOptions);
		fileStoragehash = overRideDatFileOptions;
		_this.writeOutDatFile();
	}

	//@@@@@@@@ CALC ALL  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.calcAll = function(inPostFunction){
		var allResults = [];
		finish.map(Object.keys(fileStoragehash), function(theItem, done){
			_this.calcForKey(theItem, function(inResultOfItem){
				allResults.push(inResultOfItem);
				done();
			});
		},//completed Function--------------------------------
		function(err, results){
			if(inPostFunction){
				inPostFunction(allResults);
			}
		});
	}
	//@@@@@@@@ CALC    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.calcForKey = function(inStorageKey, inPostFunction){
		var theFolderBasePath = fileStoragehash[inStorageKey].folderBasePath;
		if(!(fileStoragehash[inStorageKey])){return false;}
		fs.readdir(theFolderBasePath, function(err, files){
			var totalFileCount = 0;
			var totalFileSizeBytes = 0;

			fileStoragehash[inStorageKey].currentTotalFolderCount = 0; //4.21.15 add   currentTotalFileSize
			fileStoragehash[inStorageKey].currentTotalFileCount = 0; //4.21.15 add 
			fileStoragehash[inStorageKey].currentTotalFileSize = 0; //4.21.15 add

			fileStoragehash[inStorageKey].folders = {};
			var folders = fileStoragehash[inStorageKey].folders;
			for(var fileIndex in files){
				if(fs.statSync(path.join(theFolderBasePath, files[fileIndex])).isDirectory()){
					//FOLDER-----
					fileStoragehash[inStorageKey].currentTotalFolderCount++;
					folders[files[fileIndex]] = 
						{
							name:files[fileIndex],
							fullPath:theFolderBasePath + files[fileIndex],
							currentFolderFileCount:0,
							currentFolderFileSizeBytes:0,
						}
				}else{
					//FILE-----------
				}
			}
			//process the folders.....
			var doOnce = true;
			var totalVacantCount = 0;
			
			finish.map(folders, function(folder, done){
				if(doOnce){
					doOnce = false;
					fileStoragehash[inStorageKey].leastFolderCount = 10000000;
				}
				fs.readdir(folder.fullPath, function(err, inFiles){
					fileStoragehash[inStorageKey].useFolderPath = folder.name;//primer

					for(var inFileIndex in inFiles){
						if(fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).isDirectory()){
							//ignored, only 1 level processing, switch to recursion if want more...
						}else{
							folder.currentFolderFileCount++,
							folder.currentFolderFileSizeBytes += fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).size;
						}
					}
					if(folder.currentFolderFileCount < fileStoragehash[inStorageKey].maxFolderFileCount){
						totalVacantCount += (fileStoragehash[inStorageKey].maxFolderFileCount - folder.currentFolderFileCount);
					}
					
					

					fileStoragehash[inStorageKey].currentTotalFileCount += folder.currentFolderFileCount;
					fileStoragehash[inStorageKey].currentTotalFileSize += folder.currentFolderFileSizeBytes;
					done();
				});
			},
			//completed Function--------------------------------
			function(err, results){
				_this.pickMostVacantFolder(inStorageKey);
				fileStoragehash[inStorageKey].currentFolderUsageCountPercent = (100 - (totalVacantCount / ((Object.keys(fileStoragehash[inStorageKey].folders).length) * fileStoragehash[inStorageKey].maxFolderFileCount)) * 100);
				
				if(inPostFunction){
					inPostFunction(fileStoragehash[inStorageKey]);
				}
			});
		});
	}

	_this.pickMostVacantFolder = function(inStorageKey){
		var theStruct = fileStoragehash[inStorageKey].folders;
		var leastCount = 1000000;
		var tmp = false;
		for(theKey in theStruct){
			if(theStruct[theKey].currentFolderFileCount < leastCount){
				leastCount = theStruct[theKey].currentFolderFileCount;
				tmp = theKey;
			}
		}
		fileStoragehash[inStorageKey].leastFolderCount = leastCount;
		fileStoragehash[inStorageKey].useFolderPath = tmp;
	}

	this.checkAndCreateVacancy = function(inPostFunction){
		var resultBool = false;
		_this.calcAll(function(result){
			for(var theKey in fileStoragehash){
				
				if(isNaN(fileStoragehash[theKey].currentFolderUsageCountPercent)){
					_this.createFolder(theKey);
				}
				
				if(fileStoragehash[theKey].currentFolderUsageCountPercent >= fileStoragehash[theKey].createNewFolderUsageCountPercent){
					resultBool = true;
					_this.createFolder(theKey);
				}
			}
			_this.calcAll(function(result){
				if(inPostFunction){inPostFunction(resultBool);}
			});
		});
	}

	this.createFolder = function(inStorageKey){
		var baseFolderPath = fileStoragehash[inStorageKey].folderBasePath;
		var newFolderName = uuid.v1();
		var fullPath = baseFolderPath + newFolderName;
		fs.mkdirSync(fullPath);
		fileStoragehash[inStorageKey].folders[newFolderName] =
			{
				name:newFolderName,
				fullPath:fullPath,
				currentFolderFileCount:0,
				currentFolderFileSizeBytes:0,
			}

		fileStoragehash[inStorageKey].useFolderPath = newFolderName;
	}

	//@@@@@ OLD SCHOOL TIMER WAY @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.startCycle = function(inInterval, inCycleFunction){
		_this.readInDatFile();
		var theCycleFunction = function(){
			_this.checkAndCreateVacancy(function(hadIncrease){
				_this.writeOutDatFile();
				timerId = setTimeout(function(){ theCycleFunction(); }, inInterval);
			});
		}
		theCycleFunction();
	}

	this.stopCycle = function(){
		if(timerId){
			clearTimeout(timerId);
		}
	}
	//END @@@@@ OLD SCHOOL TIMER WAY @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	this.cycleNow = function(inPostFunction){
		_this.readInDatFile();
		_this.checkAndCreateVacancy(function(hadIncrease){
			_this.writeOutDatFile();
			if(inPostFunction){inPostFunction(_this.cycleNow);}
		});
	}

	//@@@@@@@@ INSERT ((ALL)) FILE DATA TO DATABASE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.insertAllFileDataToDatabase = function(inGroupKey, inPostFunction){
		_this.readInDatFile();
		if(!(inGroupKey)){
			inGroupKey = uuid.v4();
		}
		var theKeys = Object.keys(fileStoragehash);
		finish.map(theKeys, function(theKey, done){
			_this.insertFileDataToDatabase(theKey, inGroupKey, function(){
				done();
			});
		},
		//completed Function--------------------------------
		function(err, results){
			if(inPostFunction){
				inPostFunction();
			}
		});
	}

	//@@@@@@@@ INSERT FILE DATA TO DATABASE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	this.insertFileDataToDatabase = function(inStorageKey, inGroupKey, inPostFunction){
		global.reportNotify('[filestorageserver.js]insertFileDataToDatabase entered', {inStorageKey:inStorageKey}, 0);
		_this.readInDatFile();
		var theStorageContainerObject = fileStoragehash[inStorageKey];
		if(theStorageContainerObject){
			var theStorageContainer = [];
			for(var theKey in theStorageContainerObject.folders){
				theStorageContainer.push(theStorageContainerObject.folders[theKey]);
			}
			global.reportNotify('testPoint_0', {theStorageContainer:theStorageContainer}, 0);
			finish.map(theStorageContainer, function(folder, done){
				global.reportNotify('MAP insertFileDataToDatabase', {folder:folder,theStorageContainerObject:theStorageContainerObject}, 0);
				var folderFullPath = theStorageContainerObject.folderBasePath + folder.name;
				var dataArray = [];
				//loop the files and push dataArray
				fs.readdir(folderFullPath, function(err, inFiles){
					if(err){
						global.reportError('FileStorageServer.insertFileDataToDatabase()',
							{
									error:err,
									inFiles:inFiles,
									inStorageKey:inStorageKey,
									inGroupKey:inGroupKey,
							}, 0
						);
					}
					for(var inFileIndex in inFiles){
						if(fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).isDirectory()){
							// do nothing for inner folders -----
						}else{
								dataArray.push(
								{
									storageKey 		:inStorageKey,
									groupKey 		:inGroupKey,
									serverPath 		:folderFullPath + '/' + inFiles[inFileIndex],
									domainPath 		:theStorageContainerObject.folderDomainPath + folder.name + '/' + inFiles[inFileIndex],
									fileNameAndExt 	:inFiles[inFileIndex],
									ext 			:path.extname(folderFullPath + inFiles[inFileIndex]).replace('.',''), 
									modifyTime 		:moment(fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).mtime).format("YYYY-MM-DD HH:mm:ss"),
									accessTime 		:moment(fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).atime).format("YYYY-MM-DD HH:mm:ss"),
									createTime 		:moment(fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).ctime).format("YYYY-MM-DD HH:mm:ss"),
									sizeBytes 		:fs.statSync(path.join(folder.fullPath, inFiles[inFileIndex])).size, 
									specialAttrib 	:'',
								}
							);
						}
					}// end FOR

					//store to db-----
					fileStorageServerModel.clearFileDataFromDb(function(){
						fileStorageServerModel.insertFileDataToDatabase(
							{
								dataArray:dataArray,
							}, function(){
								done();
							}
						);
					});
				});


			},
			//completed Function--------------------------------
			function(err, results){
				if(inPostFunction){
					inPostFunction();
				}
			});
		}

	}

	this.deleteOrphans = function(inDeleteOrphansOptions, inPostFunction){
		var deleteOrphansOptions = 
			{
				//storageKey:'%',
				//groupKey:'%',
				//ageMinutes:0,
				//limit:3
			}
		deleteOrphansOptions = extend(true, deleteOrphansOptions, inDeleteOrphansOptions);
		fileStorageServerModel.getDeletables(deleteOrphansOptions, function(err, result){
			if(!(err)){
				for(theIndex in result){
					_this.deleteFile(result[theIndex].serverPath);
				}
			}
			if(inPostFunction){inPostFunction();}
		});


	}

	this.deleteFile = function(inFullPath){
		if(inFullPath){
			try{
				fs.unlinkSync(inFullPath);
			}catch(e){
				global.reportError('FileStorageServer.deleteFile()', {error:e, caption:'inFullPath'}, 0);
				return false;
			}
			global.reportDeleteFile('FILE DELETED ', inFullPath, 0);
			return true;
		}
	}

}
module.exports = FileStorageServer;

